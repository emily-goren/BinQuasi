betas$setup = rep(c('JIL', 'Uniform+Pareto'), each = regions)
betas$Peak = factor(rep(is.peak, times = 2))
# Draw counts.
I.JIL <- lapply(1:reps, function(r) MASS::rnegbin(regions, mu = mu.I.JIL, theta = 1/phi))
C.JIL <- lapply(1:reps, function(r) MASS::rnegbin(regions, mu = mu.C.JIL, theta = 1/phi))
I.sim <- lapply(1:reps, function(r) MASS::rnegbin(regions, mu = mu.I.sim, theta = 1/phi))
C.sim <- lapply(1:reps, function(r) MASS::rnegbin(regions, mu = mu.C.sim, theta = 1/phi))
cts.JIL <- append(C.JIL, I.JIL)
cts.sim <- append(C.sim, I.sim)
names(cts.JIL) <- names(cts.sim) <- samples
cts.JIL <- data.frame(do.call('cbind', cts.JIL))
cts.sim <- data.frame(do.call('cbind', cts.sim))
# Create design matrix for QuasiSeq.
design.list <- as.list(rep(NA, 2))
design.list[[1]] <- as.matrix( cbind(rep(1, reps*2),
rep(c(1,0), each = reps)))
design.list[[2]] <- as.matrix(cbind(rep(1, reps*2)))
# Function to run BQ analysis.
run.BQ <- function(cts.trim, design.list) {
# By hand MLEs.
y1 <- cts.trim[ , 1:reps]
y2 <- cts.trim[ , (reps+1):(2*reps)]
b0.MLE <- log(apply(y2, 1, mean))
b1.MLE <- log(apply(y1, 1, mean)) - log(apply(y2, 1, mean))
keep <- rowSums(cts.trim) > 0
cts.trim <- cts.trim[keep, ]
K <- nrow(cts.trim)
keep <- (1:K)[keep]
# Normalization factor.
size <- rep(1, length(samples))
# Fit Quasi models.
require(QuasiSeqIC)
invisible(capture.output(fit.NB <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "NegBin",
print.progress = FALSE)))
invisible(capture.output(fit.Pois <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "Poisson",
print.progress = FALSE)))
# Extract results.
invisible(capture.output(res.NB2 <- QL.results(fit.NB, Plot = FALSE)))
invisible(capture.output(res.NB1 <- QL.results(fit.NB, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
invisible(capture.output(res.Pois2 <- QL.results(fit.Pois, Plot = FALSE)))
invisible(capture.output(res.Pois1 <- QL.results(fit.Pois, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
# Get estimated NB dispersions.
NB.disp.est <- rep(NA, K)
NB.disp.est[keep] <- fit.NB$NB.disp
# Fit GLM models.
X <- rep(c(1,0), each = reps)
res.Pois <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = poisson()))
if (fit.full$converged != TRUE)
print(cat(paste0('Full Poisson GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = poisson()))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced Poisson GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red) - deviance(fit.full)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
if (coef(fit.full)[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
return(c(coef(fit.full), p))
})
res.Pois <- do.call('rbind', res.Pois)
th <- fit.NB$NB.disp
require(MASS)
res.NB <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = negative.binomial(theta = th[w])))
if (fit.full$converged != TRUE)
print(cat(paste0('Full NegBin GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = negative.binomial(theta = th[w])))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced NegBin GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red, dispersion = 1) - deviance(fit.full, dispersion = 1)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
b <- coef(fit.full)
if (b[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
if (fit.full$converged != TRUE | fit.red$converged != TRUE) {
b <- rep(NA, 2)
p <- NA
}
return(c(b, p))
})
res.NB <- do.call('rbind', res.NB)
# Get estimated intercepts.
b0.NB2 <- b0.NB1 <- b0.Pois2 <- b0.Pois1 <- b0.Pois <-  b0.NB  <- rep(NA, K)
b0.NB2[keep] <- fit.NB$coefficients[ ,1]
b0.NB1[keep] <- fit.NB$coefficients.constrained[ ,1]
b0.Pois2[keep] <- fit.Pois$coefficients[ ,1]
b0.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,1]
b0.Pois[keep] <- res.Pois[ ,1]
b0.NB[keep] <- res.NB[ ,1]
# Get estimated ChIP coefficients.
b1.NB2 <- b1.NB1 <- b1.Pois2 <- b1.Pois1 <- b1.Pois <-  b1.NB <- rep(NA, K)
b1.NB2[keep] <- fit.NB$coefficients[ ,2]
b1.NB1[keep] <- fit.NB$coefficients.constrained[ ,2]
b1.Pois2[keep] <- fit.Pois$coefficients[ ,2]
b1.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,2]
b1.Pois[keep] <- res.Pois[ ,2]
b1.NB[keep] <- res.NB[ ,2]
# Plot quasi-seq vs glm estimates.
d <- data.frame(b0.GLM = c(b0.Pois[keep], b0.NB[keep]),
b0.QL = c(b0.Pois2[keep], b0.NB2[keep]),
b0.MLE = rep(b0.MLE[keep], 2),
b1.GLM = c(b1.Pois[keep], b1.NB[keep]),
b1.QL = c(b1.Pois2[keep], b1.NB2[keep]),
b1.MLE = rep(b1.MLE[keep], 2),
dist = rep(c('Poisson', 'NegBin'), each = length(keep)))
# Get estimated quasi-dispersions.
phi.NB <- phi.Pois <- rep(NA, K)
phi.NB[keep] <- fit.NB$phi.hat.dev
phi.Pois[keep] <- fit.Pois$phi.hat.dev
# Get p-values for each method.
P.QL.NB2 <- P.LRT.NB2 <- P.QL.Pois2 <- P.LRT.Pois2 <- P.GLM.NB1 <- rep(1, K)
P.QL.NB1 <- P.LRT.NB1 <- P.QL.Pois1 <- P.LRT.Pois1 <- P.GLM.Pois1 <- rep(0.5, K)
P.QL.NB2[keep] <- as.numeric(res.NB2$P.values$QLShrink)
P.QL.NB1[keep] <- ifelse(b1.NB2[keep] >= 0, 0.5 * P.QL.NB2[keep], 0.5)
P.QL.Pois2[keep] <- as.numeric(res.Pois2$P.values$QLShrink)
P.QL.Pois1[keep] <- ifelse(b1.Pois2[keep] >= 0, 0.5 * P.QL.Pois2[keep], 0.5)
P.LRT.NB2[keep] <- pchisq(res.NB2$F.stat$QL * fit.NB$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.NB1[keep] <- ifelse(b1.NB2[keep] > 0 , P.LRT.NB2[keep] / 2, 0.5)
P.LRT.Pois2[keep] <- pchisq(res.Pois2$F.stat$QL * fit.Pois$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.Pois1[keep] <- ifelse(b1.Pois2[keep] > 0 , P.LRT.Pois2[keep] / 2, 0.5)
P.GLM.Pois1[keep] <- res.Pois[ ,3]
P.GLM.NB1[keep] <- res.NB[ ,3]
tests <- c('NegBin 2-sided QL', 'NegBin 1-sided QL', 'NegBin 1-sided LRT',
'Poisson 2-sided QL', 'Poisson 1-sided QL', 'Poisson 1-sided LRT')
dist <- rep(c('NB', 'Pois'), each = 3*K)
method <- rep(tests, each = K)
p.val <- c(P.QL.NB2, P.QL.NB1, P.LRT.NB1, P.QL.Pois2, P.QL.Pois1, P.LRT.Pois1)
q.val <- c(p.adjust(P.QL.NB2, method = 'BH'), p.adjust(P.QL.NB1, method = 'BH'),
p.adjust(P.LRT.NB1, method = 'BH'), p.adjust(P.QL.Pois2, method = 'BH'),
p.adjust(P.QL.Pois1, method = 'BH'), p.adjust(P.LRT.Pois1, method = 'BH'))
b0 <- c(b0.NB2, b0.NB1, b0.NB1, b0.Pois2, b0.Pois1, b0.Pois1)
b1 <- c(b1.NB2, b1.NB1, b1.NB1, b1.Pois2, b1.Pois1, b1.Pois1)
NB.disp.est <- c(rep(NB.disp.est, 3), rep(NA, K*3))
phi.dev <- c(phi.NB, phi.NB, rep(1, K), phi.Pois, phi.Pois, rep(1, K))
mean.C.est <- exp(b0 + b1)
mean.I.est <- exp(b0)
var.C.est <- ifelse(dist == 'NB', mean.C.est + NB.disp.est * mean.C.est^2, mean.C.est)
var.I.est <- ifelse(dist == 'NB', mean.I.est + NB.disp.est * mean.I.est^2, mean.I.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.C.est, phi.dev * var.C.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.I.est, phi.dev * var.I.est)
out <- data.frame(p.val, q.val,
beta0.est = b0,
beta1.est = b1,
NB.disp.est, NB.disp = phi,
phi.dev,
mean.C.est,
mean.I.est,
var.C.est,
var.I.est,
method,
dist, phi.dev,
peak = rep(is.peak, length(tests)))
return(out)
}
BQ <- run.BQ(cts.JIL, design.list)
dat.BQ <- do.call('rbind', BQ)
dat.BQ$Peak <- factor(dat.BQ$peak)
tests <- levels(dat.BQ$method)
str(dat.BQ)
dat.BQ <-  BQ
str(dat.BQ)
dat.BQ$Peak <- factor(dat.BQ$peak)
tests <- levels(dat.BQ$method)
require(tidyr); require(ROCR); require(RColorBrewer)
BQ <- dat.BQ[ , c("p.val", "start", "nsim", "method", "peak")]
BQ <- spread(BQ, method, p.val)
BQ <- BQ[ order(BQ$nsim, BQ$start), ]
truth <- is.peak
names <- c(levels(dat.BQ$method))
dat.BQ$Peak <- factor(dat.BQ$peak)
tests <- levels(dat.BQ$method)
require(tidyr); require(ROCR); require(RColorBrewer)
BQ <- dat.BQ[ , c("p.val", "start", "nsim", "method", "peak")]
BQ <- spread(BQ, method, p.val)
BQ <- BQ[ order(BQ$nsim, BQ$start), ]
truth <- is.peak
names <- c(levels(dat.BQ$method))
head(BQ)
names(BQ)
dat.BQ <-  BQ #do.call('rbind', BQ)
dat.BQ$Peak <- factor(dat.BQ$peak)
tests <- levels(dat.BQ$method)
require(tidyr); require(ROCR); require(RColorBrewer)
BQ <- dat.BQ[ , c("p.val", "start", "method", "peak")]
BQ <- spread(BQ, method, p.val)
BQ <- BQ[ order(BQ$nsim, BQ$start), ]
truth <- is.peak
names <- c(levels(dat.BQ$method))
dat.BQ <-  BQ #do.call('rbind', BQ)
dat.BQ$Peak <- factor(dat.BQ$peak)
tests <- levels(dat.BQ$method)
require(tidyr); require(ROCR); require(RColorBrewer)
tests
head(dat.BQ)
names(dat.BQ)
# By hand MLEs.
y1 <- cts.trim[ , 1:reps]
y2 <- cts.trim[ , (reps+1):(2*reps)]
b0.MLE <- log(apply(y2, 1, mean))
b1.MLE <- log(apply(y1, 1, mean)) - log(apply(y2, 1, mean))
keep <- rowSums(cts.trim) > 0
cts.trim <- cts.trim[keep, ]
K <- nrow(cts.trim)
keep <- (1:K)[keep]
# Normalization factor.
size <- rep(1, length(samples))
# Fit Quasi models.
require(QuasiSeqIC)
invisible(capture.output(fit.NB <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "NegBin",
print.progress = FALSE)))
invisible(capture.output(fit.Pois <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "Poisson",
print.progress = FALSE)))
# Extract results.
invisible(capture.output(res.NB2 <- QL.results(fit.NB, Plot = FALSE)))
invisible(capture.output(res.NB1 <- QL.results(fit.NB, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
invisible(capture.output(res.Pois2 <- QL.results(fit.Pois, Plot = FALSE)))
invisible(capture.output(res.Pois1 <- QL.results(fit.Pois, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
# Get estimated NB dispersions.
NB.disp.est <- rep(NA, K)
NB.disp.est[keep] <- fit.NB$NB.disp
# Fit GLM models.
X <- rep(c(1,0), each = reps)
res.Pois <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = poisson()))
if (fit.full$converged != TRUE)
print(cat(paste0('Full Poisson GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = poisson()))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced Poisson GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red) - deviance(fit.full)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
if (coef(fit.full)[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
return(c(coef(fit.full), p))
})
res.Pois <- do.call('rbind', res.Pois)
th <- fit.NB$NB.disp
require(MASS)
res.NB <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = negative.binomial(theta = th[w])))
if (fit.full$converged != TRUE)
print(cat(paste0('Full NegBin GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = negative.binomial(theta = th[w])))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced NegBin GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red, dispersion = 1) - deviance(fit.full, dispersion = 1)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
b <- coef(fit.full)
if (b[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
if (fit.full$converged != TRUE | fit.red$converged != TRUE) {
b <- rep(NA, 2)
p <- NA
}
return(c(b, p))
})
res.NB <- do.call('rbind', res.NB)
# Get estimated intercepts.
b0.NB2 <- b0.NB1 <- b0.Pois2 <- b0.Pois1 <- b0.Pois <-  b0.NB  <- rep(NA, K)
b0.NB2[keep] <- fit.NB$coefficients[ ,1]
b0.NB1[keep] <- fit.NB$coefficients.constrained[ ,1]
b0.Pois2[keep] <- fit.Pois$coefficients[ ,1]
b0.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,1]
b0.Pois[keep] <- res.Pois[ ,1]
b0.NB[keep] <- res.NB[ ,1]
# Get estimated ChIP coefficients.
b1.NB2 <- b1.NB1 <- b1.Pois2 <- b1.Pois1 <- b1.Pois <-  b1.NB <- rep(NA, K)
b1.NB2[keep] <- fit.NB$coefficients[ ,2]
b1.NB1[keep] <- fit.NB$coefficients.constrained[ ,2]
b1.Pois2[keep] <- fit.Pois$coefficients[ ,2]
b1.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,2]
b1.Pois[keep] <- res.Pois[ ,2]
b1.NB[keep] <- res.NB[ ,2]
# Plot quasi-seq vs glm estimates.
d <- data.frame(b0.GLM = c(b0.Pois[keep], b0.NB[keep]),
b0.QL = c(b0.Pois2[keep], b0.NB2[keep]),
b0.MLE = rep(b0.MLE[keep], 2),
b1.GLM = c(b1.Pois[keep], b1.NB[keep]),
b1.QL = c(b1.Pois2[keep], b1.NB2[keep]),
b1.MLE = rep(b1.MLE[keep], 2),
dist = rep(c('Poisson', 'NegBin'), each = length(keep)))
# Get estimated quasi-dispersions.
phi.NB <- phi.Pois <- rep(NA, K)
phi.NB[keep] <- fit.NB$phi.hat.dev
phi.Pois[keep] <- fit.Pois$phi.hat.dev
# Get p-values for each method.
P.QL.NB2 <- P.LRT.NB2 <- P.QL.Pois2 <- P.LRT.Pois2 <- P.GLM.NB1 <- rep(1, K)
P.QL.NB1 <- P.LRT.NB1 <- P.QL.Pois1 <- P.LRT.Pois1 <- P.GLM.Pois1 <- rep(0.5, K)
P.QL.NB2[keep] <- as.numeric(res.NB2$P.values$QLShrink)
P.QL.NB1[keep] <- ifelse(b1.NB2[keep] >= 0, 0.5 * P.QL.NB2[keep], 0.5)
P.QL.Pois2[keep] <- as.numeric(res.Pois2$P.values$QLShrink)
P.QL.Pois1[keep] <- ifelse(b1.Pois2[keep] >= 0, 0.5 * P.QL.Pois2[keep], 0.5)
P.LRT.NB2[keep] <- pchisq(res.NB2$F.stat$QL * fit.NB$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.NB1[keep] <- ifelse(b1.NB2[keep] > 0 , P.LRT.NB2[keep] / 2, 0.5)
P.LRT.Pois2[keep] <- pchisq(res.Pois2$F.stat$QL * fit.Pois$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.Pois1[keep] <- ifelse(b1.Pois2[keep] > 0 , P.LRT.Pois2[keep] / 2, 0.5)
P.GLM.Pois1[keep] <- res.Pois[ ,3]
P.GLM.NB1[keep] <- res.NB[ ,3]
tests <- c('NegBin 2-sided QL', 'NegBin 1-sided QL', 'NegBin 1-sided LRT',
'Poisson 2-sided QL', 'Poisson 1-sided QL', 'Poisson 1-sided LRT')
dist <- rep(c('NB', 'Pois'), each = 3*K)
method <- rep(tests, each = K)
p.val <- c(P.QL.NB2, P.QL.NB1, P.LRT.NB1, P.QL.Pois2, P.QL.Pois1, P.LRT.Pois1)
q.val <- c(p.adjust(P.QL.NB2, method = 'BH'), p.adjust(P.QL.NB1, method = 'BH'),
p.adjust(P.LRT.NB1, method = 'BH'), p.adjust(P.QL.Pois2, method = 'BH'),
p.adjust(P.QL.Pois1, method = 'BH'), p.adjust(P.LRT.Pois1, method = 'BH'))
b0 <- c(b0.NB2, b0.NB1, b0.NB1, b0.Pois2, b0.Pois1, b0.Pois1)
b1 <- c(b1.NB2, b1.NB1, b1.NB1, b1.Pois2, b1.Pois1, b1.Pois1)
NB.disp.est <- c(rep(NB.disp.est, 3), rep(NA, K*3))
phi.dev <- c(phi.NB, phi.NB, rep(1, K), phi.Pois, phi.Pois, rep(1, K))
mean.C.est <- exp(b0 + b1)
mean.I.est <- exp(b0)
var.C.est <- ifelse(dist == 'NB', mean.C.est + NB.disp.est * mean.C.est^2, mean.C.est)
var.I.est <- ifelse(dist == 'NB', mean.I.est + NB.disp.est * mean.I.est^2, mean.I.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.C.est, phi.dev * var.C.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.I.est, phi.dev * var.I.est)
out <- data.frame(p.val, q.val,
beta0.est = b0,
beta1.est = b1,
NB.disp.est, NB.disp = phi,
phi.dev,
mean.C.est,
mean.I.est,
var.C.est,
var.I.est,
method,
dist, phi.dev,
peak = rep(is.peak, length(tests)))
cts.trim = cts.JIL
# By hand MLEs.
y1 <- cts.trim[ , 1:reps]
y2 <- cts.trim[ , (reps+1):(2*reps)]
b0.MLE <- log(apply(y2, 1, mean))
b1.MLE <- log(apply(y1, 1, mean)) - log(apply(y2, 1, mean))
keep <- rowSums(cts.trim) > 0
cts.trim <- cts.trim[keep, ]
K <- nrow(cts.trim)
keep <- (1:K)[keep]
# Normalization factor.
size <- rep(1, length(samples))
# Fit Quasi models.
require(QuasiSeqIC)
invisible(capture.output(fit.NB <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "NegBin",
print.progress = FALSE)))
invisible(capture.output(fit.Pois <- QL.fit(cts.trim,
design.list, bias.fold.tolerance=1.1,
log.offset = log(size),
Model = "Poisson",
print.progress = FALSE)))
# Extract results.
invisible(capture.output(res.NB2 <- QL.results(fit.NB, Plot = FALSE)))
invisible(capture.output(res.NB1 <- QL.results(fit.NB, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
invisible(capture.output(res.Pois2 <- QL.results(fit.Pois, Plot = FALSE)))
invisible(capture.output(res.Pois1 <- QL.results(fit.Pois, Plot = FALSE, constrain = TRUE, type = 'Fbar')))
# Get estimated NB dispersions.
NB.disp.est <- rep(NA, K)
NB.disp.est[keep] <- fit.NB$NB.disp
# Fit GLM models.
X <- rep(c(1,0), each = reps)
res.Pois <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = poisson()))
if (fit.full$converged != TRUE)
print(cat(paste0('Full Poisson GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = poisson()))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced Poisson GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red) - deviance(fit.full)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
if (coef(fit.full)[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
return(c(coef(fit.full), p))
})
res.Pois <- do.call('rbind', res.Pois)
th <- fit.NB$NB.disp
require(MASS)
res.NB <- lapply(1:nrow(cts.trim), function(w) {
y <- as.numeric(cts.trim[w, ])
fit.full <- suppressWarnings(glm(y ~ X, family = negative.binomial(theta = th[w])))
if (fit.full$converged != TRUE)
print(cat(paste0('Full NegBin GLM did not converge in window ', (1:K)[w], '\n')))
fit.red <- suppressWarnings(glm(y ~ 1, family = negative.binomial(theta = th[w])))
if (fit.red$converged != TRUE)
print(cat(paste0('Reduced NegBin GLM did not converge in window ', (1:K)[w], '\n')))
LRT <- deviance(fit.red, dispersion = 1) - deviance(fit.full, dispersion = 1)
LRT[LRT < 0] <- 0
p <- pchisq(LRT, 1, lower.tail = FALSE)
b <- coef(fit.full)
if (b[2] >= 0) {
p <- 0.5 * p
} else {
p <- 0.5
}
if (fit.full$converged != TRUE | fit.red$converged != TRUE) {
b <- rep(NA, 2)
p <- NA
}
return(c(b, p))
})
res.NB <- do.call('rbind', res.NB)
# Get estimated intercepts.
b0.NB2 <- b0.NB1 <- b0.Pois2 <- b0.Pois1 <- b0.Pois <-  b0.NB  <- rep(NA, K)
b0.NB2[keep] <- fit.NB$coefficients[ ,1]
b0.NB1[keep] <- fit.NB$coefficients.constrained[ ,1]
b0.Pois2[keep] <- fit.Pois$coefficients[ ,1]
b0.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,1]
b0.Pois[keep] <- res.Pois[ ,1]
b0.NB[keep] <- res.NB[ ,1]
# Get estimated ChIP coefficients.
b1.NB2 <- b1.NB1 <- b1.Pois2 <- b1.Pois1 <- b1.Pois <-  b1.NB <- rep(NA, K)
b1.NB2[keep] <- fit.NB$coefficients[ ,2]
b1.NB1[keep] <- fit.NB$coefficients.constrained[ ,2]
b1.Pois2[keep] <- fit.Pois$coefficients[ ,2]
b1.Pois1[keep] <- fit.Pois$coefficients.constrained[ ,2]
b1.Pois[keep] <- res.Pois[ ,2]
b1.NB[keep] <- res.NB[ ,2]
# Plot quasi-seq vs glm estimates.
d <- data.frame(b0.GLM = c(b0.Pois[keep], b0.NB[keep]),
b0.QL = c(b0.Pois2[keep], b0.NB2[keep]),
b0.MLE = rep(b0.MLE[keep], 2),
b1.GLM = c(b1.Pois[keep], b1.NB[keep]),
b1.QL = c(b1.Pois2[keep], b1.NB2[keep]),
b1.MLE = rep(b1.MLE[keep], 2),
dist = rep(c('Poisson', 'NegBin'), each = length(keep)))
# Get estimated quasi-dispersions.
phi.NB <- phi.Pois <- rep(NA, K)
phi.NB[keep] <- fit.NB$phi.hat.dev
phi.Pois[keep] <- fit.Pois$phi.hat.dev
# Get p-values for each method.
P.QL.NB2 <- P.LRT.NB2 <- P.QL.Pois2 <- P.LRT.Pois2 <- P.GLM.NB1 <- rep(1, K)
P.QL.NB1 <- P.LRT.NB1 <- P.QL.Pois1 <- P.LRT.Pois1 <- P.GLM.Pois1 <- rep(0.5, K)
P.QL.NB2[keep] <- as.numeric(res.NB2$P.values$QLShrink)
P.QL.NB1[keep] <- ifelse(b1.NB2[keep] >= 0, 0.5 * P.QL.NB2[keep], 0.5)
P.QL.Pois2[keep] <- as.numeric(res.Pois2$P.values$QLShrink)
P.QL.Pois1[keep] <- ifelse(b1.Pois2[keep] >= 0, 0.5 * P.QL.Pois2[keep], 0.5)
P.LRT.NB2[keep] <- pchisq(res.NB2$F.stat$QL * fit.NB$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.NB1[keep] <- ifelse(b1.NB2[keep] > 0 , P.LRT.NB2[keep] / 2, 0.5)
P.LRT.Pois2[keep] <- pchisq(res.Pois2$F.stat$QL * fit.Pois$phi.hat.dev, df = 1, lower.tail = FALSE)
P.LRT.Pois1[keep] <- ifelse(b1.Pois2[keep] > 0 , P.LRT.Pois2[keep] / 2, 0.5)
P.GLM.Pois1[keep] <- res.Pois[ ,3]
P.GLM.NB1[keep] <- res.NB[ ,3]
tests <- c('NegBin 2-sided QL', 'NegBin 1-sided QL', 'NegBin 1-sided LRT',
'Poisson 2-sided QL', 'Poisson 1-sided QL', 'Poisson 1-sided LRT')
dist <- rep(c('NB', 'Pois'), each = 3*K)
method <- rep(tests, each = K)
p.val <- c(P.QL.NB2, P.QL.NB1, P.LRT.NB1, P.QL.Pois2, P.QL.Pois1, P.LRT.Pois1)
q.val <- c(p.adjust(P.QL.NB2, method = 'BH'), p.adjust(P.QL.NB1, method = 'BH'),
p.adjust(P.LRT.NB1, method = 'BH'), p.adjust(P.QL.Pois2, method = 'BH'),
p.adjust(P.QL.Pois1, method = 'BH'), p.adjust(P.LRT.Pois1, method = 'BH'))
b0 <- c(b0.NB2, b0.NB1, b0.NB1, b0.Pois2, b0.Pois1, b0.Pois1)
b1 <- c(b1.NB2, b1.NB1, b1.NB1, b1.Pois2, b1.Pois1, b1.Pois1)
NB.disp.est <- c(rep(NB.disp.est, 3), rep(NA, K*3))
phi.dev <- c(phi.NB, phi.NB, rep(1, K), phi.Pois, phi.Pois, rep(1, K))
mean.C.est <- exp(b0 + b1)
mean.I.est <- exp(b0)
var.C.est <- ifelse(dist == 'NB', mean.C.est + NB.disp.est * mean.C.est^2, mean.C.est)
var.I.est <- ifelse(dist == 'NB', mean.I.est + NB.disp.est * mean.I.est^2, mean.I.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.C.est, phi.dev * var.C.est)
var.C.est <- ifelse(method %in% c('NegBin 1-sided LRT', 'Poisson 1-sided LRT'), var.I.est, phi.dev * var.I.est)
out <- data.frame(p.val, q.val,
beta0.est = b0,
beta1.est = b1,
NB.disp.est, NB.disp = phi,
phi.dev,
mean.C.est,
mean.I.est,
var.C.est,
var.I.est,
method,
dist, phi.dev,
peak = rep(is.peak, length(tests)))
out
head(out)
